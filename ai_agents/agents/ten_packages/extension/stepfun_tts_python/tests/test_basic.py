import sys
from pathlib import Path

# Add project root to sys.path to allow running tests from this directory
# The project root is 6 levels up from the parent directory of this file.
project_root = str(Path(__file__).resolve().parents[6])
if project_root not in sys.path:
    sys.path.insert(0, project_root)

#
# Copyright © 2024 Agora
# This file is part of TEN Framework, an open source project.
# Licensed under the Apache License, Version 2.0, with certain conditions.
# Refer to the "LICENSE" file in the root directory for more information.
#
import json
from typing import Any
from unittest.mock import patch, AsyncMock
import tempfile
import os
import asyncio
import filecmp
import shutil
import threading

from ten_runtime import (
    ExtensionTester,
    TenEnvTester,
    Cmd,
    CmdResult,
    StatusCode,
    Data,
)
from ten_ai_base.struct import TTSTextInput, TTSFlush
from ten_ai_base.message import ModuleVendorException, ModuleErrorVendorInfo


# ================ test dump ================
class ExtensionTesterDump(ExtensionTester):
    def __init__(self):
        super().__init__()
        # Use a fixed path as requested by the user.
        self.dump_dir = "./dump/"
        # Use a unique name for the file generated by the test to avoid collision
        # with the file generated by the extension.
        self.test_dump_file_path = os.path.join(
            self.dump_dir, "test_manual_dump.pcm"
        )
        self.audio_end_received = False
        self.received_audio_chunks = []

    def on_start(self, ten_env_tester: TenEnvTester) -> None:
        """Called when test starts, sends a TTS request."""
        ten_env_tester.log_info("Dump test started, sending TTS request.")

        tts_input = TTSTextInput(
            request_id="tts_request_1",
            text="智能阶跃，十倍每个人的可能",
            text_input_end=True,
        )
        data = Data.create("tts_text_input")
        data.set_property_from_json(None, tts_input.model_dump_json())
        ten_env_tester.send_data(data)
        ten_env_tester.on_start_done()

    def on_data(self, ten_env: TenEnvTester, data) -> None:
        name = data.get_name()
        if name == "tts_audio_end":
            ten_env.log_info("Received tts_audio_end, stopping test.")
            self.audio_end_received = True
            ten_env.stop_test()

    def on_audio_frame(self, ten_env: TenEnvTester, audio_frame):
        """Receives audio frames and collects their data using the lock/unlock pattern."""
        # The 'audio_frame' object is a wrapper around a memory buffer.
        # We must lock the buffer to safely access the data, copy it,
        # and finally unlock the buffer so the runtime can reuse it.
        buf = audio_frame.lock_buf()
        try:
            # We must copy the data from the buffer, as the underlying memory
            # may be freed or reused after we unlock it.
            copied_data = bytes(buf)
            self.received_audio_chunks.append(copied_data)
        finally:
            # Always ensure the buffer is unlocked, even if an error occurs.
            audio_frame.unlock_buf(buf)

    def write_test_dump_file(self):
        """Writes the collected audio chunks to a file."""
        with open(self.test_dump_file_path, "wb") as f:
            for chunk in self.received_audio_chunks:
                f.write(chunk)

    def find_tts_dump_file(self) -> str | None:
        """Find the dump file created by the TTS extension in the fixed dump directory."""
        if not os.path.exists(self.dump_dir):
            return None
        for filename in os.listdir(self.dump_dir):
            if filename.endswith(".pcm") and filename != os.path.basename(
                self.test_dump_file_path
            ):
                return os.path.join(self.dump_dir, filename)
        return None


@patch("stepfun_tts_python.extension.StepFunTTS")
def test_dump_functionality(MockStepFunTTS):
    """Test that the extension can dump audio to a file."""
    # Create dump directory if it doesn't exist
    dump_dir = "./dump/"
    os.makedirs(dump_dir, exist_ok=True)

    # Mock the StepFunTTS class
    mock_client_instance = AsyncMock()

    # Mock the get method to return audio data as async generator
    async def mock_get(text, request_id):
        # Return audio data in the expected format
        yield b"fake_audio_data_1", 1, 123  # EVENT_TTS_RESPONSE
        yield b"fake_audio_data_2", 1, None  # EVENT_TTS_RESPONSE
        yield None, 2, None  # EVENT_TTS_REQUEST_END

    # Set the mock method
    mock_client_instance.get = mock_get
    mock_client_instance.clean = AsyncMock()
    mock_client_instance.reset = AsyncMock()

    # Set up required attributes
    mock_client_instance.client = AsyncMock()
    mock_client_instance.config = AsyncMock()
    mock_client_instance.ten_env = AsyncMock()
    mock_client_instance.send_text_in_connection = False
    mock_client_instance.cur_request_id = ""

    # Mock the constructor to return our mock instance
    MockStepFunTTS.return_value = mock_client_instance

    # Mock the _initialize_client method to avoid actual initialization
    mock_client_instance._initialize_client = AsyncMock()

    # Create and run the tester
    tester = ExtensionTesterDump()

    # Set up dump configuration
    dump_config = {
        "dump": True,
        "dump_path": dump_dir,
        "params": {
            "api_key": "fake_api_key_for_mock_testing",
            "model": "step-tts-mini",
            "voice": "cixingnansheng",
            "response_format": "mp3",
            "speed": 1.0,
            "volume": 1.0,
            "sample_rate": 24000,
        },
    }

    tester.set_test_mode_single("stepfun_tts_python", json.dumps(dump_config))
    tester.run()

    # Verify that audio end was received
    assert tester.audio_end_received, "Audio end event was not received"

    # Write test dump file for comparison
    tester.write_test_dump_file()


# ================ test basic functionality ================
class ExtensionTesterBasic(ExtensionTester):
    def __init__(self):
        super().__init__()
        self.audio_end_received = False

    def on_start(self, ten_env_tester: TenEnvTester) -> None:
        """Called when test starts, sends a TTS request."""
        ten_env_tester.log_info("Basic test started, sending TTS request.")

        tts_input = TTSTextInput(
            request_id="tts_request_1",
            text="智能阶跃，十倍每个人的可能",
            text_input_end=True,
        )
        data = Data.create("tts_text_input")
        data.set_property_from_json(None, tts_input.model_dump_json())
        ten_env_tester.send_data(data)
        ten_env_tester.on_start_done()

    def on_data(self, ten_env: TenEnvTester, data) -> None:
        name = data.get_name()
        if name == "tts_audio_end":
            ten_env.log_info("Received tts_audio_end, stopping test.")
            self.audio_end_received = True
            ten_env.stop_test()


@patch("stepfun_tts_python.extension.StepFunTTS")
def test_basic_functionality(MockStepFunTTS):
    """Test basic TTS functionality."""
    # Mock the StepFunTTS class
    mock_client_instance = AsyncMock()

    # Mock the get method to return audio data
    async def mock_get(text, request_id):
        # Return audio data in the expected format
        yield b"fake_audio_data", 1, 123  # EVENT_TTS_RESPONSE
        yield None, 2, None  # EVENT_TTS_REQUEST_END

    mock_client_instance.get = mock_get
    mock_client_instance.clean = AsyncMock()
    mock_client_instance.reset = AsyncMock()

    # Set up required attributes
    mock_client_instance.client = AsyncMock()
    mock_client_instance.config = AsyncMock()
    mock_client_instance.ten_env = AsyncMock()
    mock_client_instance.send_text_in_connection = False
    mock_client_instance.cur_request_id = ""

    # Mock the constructor to return our mock instance
    MockStepFunTTS.return_value = mock_client_instance

    # Mock the _initialize_client method to avoid actual initialization
    mock_client_instance._initialize_client = AsyncMock()

    # Create and run the tester
    tester = ExtensionTesterBasic()

    # Set up configuration
    config = {
        "params": {
            "api_key": "fake_api_key_for_mock_testing",
            "model": "step-tts-mini",
            "voice": "cixingnansheng",
            "response_format": "mp3",
            "speed": 1.0,
            "volume": 1.0,
            "sample_rate": 24000,
        },
    }

    tester.set_test_mode_single("stepfun_tts_python", json.dumps(config))
    tester.run()

    # Verify that audio end was received
    assert tester.audio_end_received, "Audio end event was not received"